12/2/19

In the interest of developing a more interesting heuristic for the board, the calculateHeuristic function is now a sum
of the number of moves possible from the board state, the number of incomplete islands, AND the number of bridges remaining.

Problem: It may be helpful to include steps-so-far as a part of the heuristic. There are spot where the program makes a wrong move,
and it's not figured out until way later. It starts reaching illegal board states, but then the next state in the frontier is also 
going to result in an illegal state, since it descended from the same ancestor.

It could easily be hundreds of runs before solving a given 'easy' puzzle without taking steps so far into account. Adding steps 
so far as a penalty would ensure that we get back to the right configuration more quickly.

Problem: Simply adding '1' to the penalty for every step doesn't have the desired effect (not soon enough anyway).
    I tried multiplying it by '2', and got some similar results, though it was better... multiplying by 3 was overkill.
    2.5 got rid of the dead ends quickly, but stifled progress beyond that. 2.1 was the same

    Perhaps an expontentiation of the steps? I started with steps**1.1, and then realized that number of complete islands was
    no longer having the intended effect. I decided to multiply that by 2. Sometimes I get done in about 20 steps or so, but  
    sometimes it takes hundreds.

    I'm going to try it the other way (1.1**steps). First try, finished in 19 steps. Then it took the wrong move and spun for more than 
    1000 steps. There's gotta be a better heuristic that can back us out of these dead ends.

----------------------------------------------------------------------------------

11/24/19

Left on boardIsVisited()

---------------------------------------------------------------------

11/23/19

In an attempt to solve the multiple connected islands problem, connect (and it's associated sub-functions) are
now functions of the board class. This also freed up some space in Search.py. 

No luck though.

Currently moving generate moves and populate adjacent into the board...
- Generate moves:
    What's the significance of moves total? We import it as a global, then reassign it to be the length of the moves set.
    Can't this be done later? I'm assuming this is not important right now, and I can move this function into the board class.
- Populate Adjacent:
    This is within generateMoves()



#-------------------------------------------------------------------------------------------------------------#

11/22/19

There is a problem with connected islands, where WAY too many islands are being put into a connected islands list.
This is happening in connect. Here is a debug print statement from the first call.

==========================================
connecting:  [6, 6]  and  [6, 4]
same column
NodeA before: []
NodeB before: []
NodeA connected: [[6, 4], [6, 6]]
NodeB connected: [[6, 4], [6, 6]]
[6, 6] [6, 4]
=======================================================

Somehow, they ended up in eachother's connected islands lists. Worse yet, it's not just these two nodes that get into
eachother's connected list, but EVERY OTHER NODE (not just islands) on the board has these in their connected island list.

This happens again in the second call to connect, but it gets worse, as more islands get added.
==========================================
connecting:  [0, 6]  and  [6, 6]
same row
NodeA before: [[6, 4], [6, 6]]
NodeB before: [[6, 4], [6, 6]]
NodeA connected: [[6, 4], [6, 6], [6, 6], [0, 6]]
NodeB connected: [[6, 4], [6, 6], [6, 6], [0, 6]]
[0, 6] [6, 6]
=======================================================

#--------------------------------------------------------------------------------------------------------------------#

11/21/19

When we there's an illegal board state (aka 1--1)...
    We need this to not happen.
        Connected islands can help us with this (or...?)

        However, connected islands is not being updated right for each node. This is apparent on the very first move.

#--------------------------------------------------------------------------------------------------------------------#


